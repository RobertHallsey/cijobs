<h1>Search Scraper, a CodeIgniter 3.0 application.</h1>

<h2>User Documentation</h2>

<p>Please see the README.MD file for installation instructions.</p>

<p>Having installed the application in CodeIgniter, you are ready to use it. Run the application in one browser tab, and in another tab, open Craigslist, Indeed, or Simply Hired. Once there, run a search for the jobs your want, setting options as you wish. The website will respond with the first page of your search results. Look at the address bar. That is the URL you will use for this search. Copy it to the clipboard and move to the tab where you're running Search Scraper.</p>

<p>Fill out the form under Add a New Search. Give the search you're about to save a meaningful name, and select which site it's from. Then paste the URL you copied to the clipboard into the Search URL field. Now click Ok to save the search and watch it appear in the list of saved searches. You edit or delete the saved by clicking the links to the right.</p>

<p>You can also execute the search. When you do so, the application will show the search and allow you to edit the URL. This is in case you have a standard search that you would like to run slightly differently just this once. After you click Ok, a CSV file with the name of your search will download. This should not take more than a few seconds, no longer than it would take to download the individual web pages in the search. The web pages are not particularly large, so with high-speed internet, even ten seconds is enough to download hundreds of rows. Again, please don't run the application carelessly or abusively, though I imagine both websites have measures to prevent abusive downloading.</p>

<p>You should know that even recent versions of Excel don't handle UTF-8 correctly when loading CSV files. It displays some multi-byte characters as multipe single-byte characters. Depending on your searches, this may not matter or it may matter very much. The workaround is to <i>import</i> the files instead of opening them. Even very old Excel versions have an import function under the Tools menu. When you import a file, you are able to select the encoding, something you can't do when you merely open it.</p>

<h2>Technical Documentation</h2>

<h3>Controllers</h3>

<p>The application has one controller, <code>Searches.php</code>. The controller's constructor loads what it needs, including the sites and saved searches from the database. There is no pagination mechanism for the data because the application is not intended to support a large number of searches or sites.</p>

<p>The controller has four methods: index, edit, delete, and execute. The index method performs the add function.</p>

<p>The index method sets form validation rules and then tests for a successful form validation. If the form validates successfully, it means it was submitted with all its fields completed, so the data is saved to the database and the application redirects to itself. From the user's point, the screen refreshes to include the added search. If the form does not validate, it means that either the form hasn't yet been presented to the user, or that the user has submitted an incomplete form. Either way, the method loads into an array the information the view will need and invokes the view.</p>

<p>The edit method is called with the ID of the search to edit. This ID is encoded in the URL the user clicks to invoke the method, and this will be explained in the View section. Once the method has the ID and retrieves the search from the database, it starts looking like the index method. It sets form validations, tests for valid form, and then either saves the edited search or refreshes the screen.</p>

<p>The delete method also must be given the ID of the search to delete, but it performs no form validation. It's not necessary since the only question is whether to delete the search or not, so the method instead tests to see if the form was submitted at all. This is the test that does that: <code>if ($this->input->server('REQUEST_METHOD') == 'POST')</code>. If the form was submitted, if the user pressed OK, the search is deleted and the screen refreshes, no longer showing the deleted search.</p>

<p>The execute method shows the search in a form, allowing you to temporarily modify the search's URL. When you press Ok, the search will use your modified URL without saving it in the database. This allows you to do just-once searches without having to first add them and then delete them. After you press Ok, the method loads the search and then loads from the application's library the class that will execute the search. It then executes the search and downloads the resulting file. The screen does not refresh because it can't. Under PHP, you can send HTTP headers that download a file <i>or</i> that redirect to a page, but you can't do both. Notice that the method executes the search using a variable reference. You may have so far seen only direct references, like <code>$this->customer_model->get_rows()</code>, but PHP allows you to put "customer_model" into a variable <code>$foo</code> and then invoke the method with <code>$this->$foo->get_rows()</code>. Finally, <code>force_download()</code> is a CodeIgniter helper function.</p>

<h3>Views</h3>

<p>The application has only one view, <code>searches_view.php</code>, which is constructed from several parts. The view itself invokes other views, including <code>header.php</code> at the very start and <code>footer.php</code> at the very end. The technique of separating header and footer code into their own files is particularly useful when you have more than one view because then you don't repeat header and footer code in every view.</p>

<p>The view is invoked with an array that passes this data.</p>

<p><pre><code>
    $data = array(
        'subview' => 'search_add_view',
        'sites' => $this->sites,
        'searches' => $this->searches,
        'search' => $search
    );
    $this->load->view('searches_view', $data);
</code></pre></p>

<p>The elements in the <code>$data</code> array are extracted as variables in searches_view.php. If there are any saved searches, the method builds a table from them, including hyperlinks to edit, delete, and execute each one. That happens in this code.</p>

<p><pre><code>
    if (count($searches))
    {
        $this->table->set_heading('Search Name', 'Job Site', 'Search URL',    'Edit', 'Delete', 'Execute');
        foreach ($searches as $search)
        {
            $this->table->add_row(
                $search['name'], $search['site_name'], $search['url'],
                anchor('searches/edit/' . $search['id'], 'Edit'), 
                anchor('searches/delete/' . $search['id'], 'Delete'),
                anchor('searches/execute/' . $search['id'], 'Execute'));
        }
        echo $this->table->generate();
    }
    else
    {
        echo '&lt;p>There are no saved searches.&lt;p/p>';
    }
</code></pre></p>

<p>After setting the table's title, the code loops through the saved searches. For each search, the code creates a table row containing the search information and functional links. The links are created by appending the search's ID to the desired controller/method.</p>

<p>Having created the table, the view must then display the form that handles individual searches. This is accomplished by having the controller pass to the view the name of the subview to use. Since the code that displays the searches as a table remains the same regardless of which subview is used, the subview technique saves us from repeating code. Without it, we'd have three complete views (add, edit, and delete), each with the same code to display searches as a table. If we later made a change to the code, we'd have to change three files instead of just one. This doesn't sound too hard, but as the number of files increases, it becomes difficult and inefficient.</p>

<p>The subview files have code in common too, and the same technique of separating common code could be used but has not been. That is left as an exercise for anyone who wants to.</p>

<h3>Libraries</h3>

<p>The application uses CodeIgniter's Driver Libraries feature. The CodeIgniter manual doesn't document this feature correctly, so until it does, <a href="http://forum.codeigniter.com/thread-63839-post-326830.html#pid326830" target="_blank">please see this forum post</a>.</p>

<h3>Writing a Library for a New Site</h3>

<p>To add a site the application can scrape, you will have to do two things. You will have to add the site to the <code>SITES</code> table in the database, and you will have to write the code, just one file, that handles the site. Of course, you will also have to study the site's code to determine the best way to extract what you want. The existing site libraries use XPath, but this is not an imposed requirement. Here's how the flow works, starting with the execute method in the controller:</p>

<pre><code>    public function execute($search_id)
    {
        $search = $this->searches_model->get_search($search_id);
        if ($this->input->server('REQUEST_METHOD') == 'POST')
        {
            $this->load->library($search['site_class']);
            $output = $this->$search['site_class']->scrape($search);
            force_download($search['name'] . '.csv', $output);
        }
        $data = array(
            'subview' => 'search_execute_view',
            'sites' => $this->sites,
            'searches' => $this->searches,
            'search' => $search
        );
        $this->load->view('searches_view', $data);
    }</code></pre>

<p>If the user clicks Ok to execute the search, the controller uses PHP's variable function feature to invoke the site's <code>scrape()</code> method and give it the search profile. The site's <code>scrape()</code> method then returns a string in <code>$output</code> consisting of the CSV file to download. So the transaction comes down to "here's a search profile, now give me the CSV output from executing that search."</p>

<p>Now let's look at the <code>scrape()</code> method.</p>

<pre><code>    public function scrape($search)
    {
        $output = '';
        $url = $search['url'];
        while ($url)
        {
            $dom = self::get_page($url);
            $xpath = new DOMXPath($dom);
            //
            // YOU MUST PROVIDE THIS CODE
            // $url = URL to the next page or '' if last page
            //
            // YOU MUST PROVIDE THIS CODE
            // $elements = $xpath->query('some-query-that-gets-you-the-rows');
            //
            foreach ($elements as $element)
            {
                $output .= self::extract_row($element);
            }
        }
        return $output;
    }</code></pre>

<p>The <code>scrape()</code> method receives the search profile in the array <code>$search</code>, and then enters a loop that continues until the variable <code>$url</code> no longer evaluates to a boolean true. Within the loop, the method uses the search URL to create a DOMDocument object in <code>$dom</code>, and then an DOMXPath object. Now comes the part that you must supply. You must write the XPath query that retrieves the URL to the next page, and if there is no next page, you must clear the <code>$url</code> variable to avoid an infinite loop. After that, you must write the XPath query that extracts the rows you want from the web page being processed. The method then loops through all the rows returned in the variable <code>$elements</code>. Note that, strictly speaking, you do not <i>have</i> to use XPath. You can also loop through the DOM and find what you want that way, but once you learn the query syntax, XPath is easy, fast, and efficient.</p>

<p>Now let's look at the <code>extract_row()</code> method.

<pre><code>    public function extract_row ($row)
    {
        // YOU MUST PROVIDE THIS CODE
        // $fields = array(
        //     'field1' => '',
        //     'field2' => '',
        //     'field3' => '',
        //     whatever fields you want
        // );
        //
        $dom = new DOMDocument;
        $dom->appendChild($dom->importNode($row, true));
        $xpath = new DOMXPath($dom);
        //
        // YOU MUST PROVIDE THIS CODE
        // extract the fields you want
        // $fields['field1'] = some-value
        //        
        $line = '"' . implode('","', $fields) . '"' . "\r\n";
        return ($line);
    }</code></pre>

<p>The method declares an array called <code>$fields</code>. The array doesn't <i>have</i> to be associative, but the keys make the code easier to read. It's much easier to assign something to <code>$field['field1']</code> than to remember the element's index number. The array also lets you set default values or create fields that aren't actually extracted from the web page.</p>

<p>The method then creates a DOMDocument object in <code>$dom</code> and adds the DOM element contained in <code>$row</code> to it. Now that it has a complete DOMDocument object, the method then creates a DOMXPath object from it. You then provide the code that extracts the fields. You might use <code>$xpath->query()</code> but you don't have to. See the included site libraries for examples.</p>

<p>After your code, the method creates a CSV line from the <code>$fields[]</code> array. PHP has functions that read and write CSV data, but Excel is picky, and I've found that using <code>implode()</code> is more reliable.</p>

<p>Regardless of the method you use to extract fields, the static method <code>clean_field()</code> can ensure your fields are "clean."</p>

<code><pre>    public function clean_field ($field)
    {
        $field = trim($field);
        $field = preg_replace('/\s\s+/', ' ', $field);
        $field = html_entity_decode($field, ENT_QUOTES);
        $field = strip_tags($field);
        $field = str_replace('"', '""', $field);
        return $field;
    }</pre></code>

<p>The method trims extra white space, converts HTML codes to characters, removes stray tags, and finally, escapes double quotes.</p>
